import { Directive, Input, Renderer2, ElementRef } from '@angular/core';
import { ColorService } from './color.service';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './color.service';
export class BackgroundColorDirective {
    constructor(elementRef, renderer2, colorService) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.colorService = colorService;
        // TODO: ADD @Required decorator
        this.condition = true;
    }
    set setPrefix(prefix) {
        this.prefix = prefix;
        this.colorService.setBackgroundColor(this.color, this.condition, this.property, this.prefix);
    }
    set setColor(color) {
        if (color) {
            this.color = color;
            this.colorService.setBackgroundColor(this.color, this.condition, this.property, this.prefix);
        }
    }
}
BackgroundColorDirective.ɵfac = function BackgroundColorDirective_Factory(t) { return new (t || BackgroundColorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ColorService)); };
BackgroundColorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BackgroundColorDirective, selectors: [["", "mkColor", ""]], inputs: { condition: ["mkColorCondition", "condition"], setPrefix: ["mkColorPrefix", "setPrefix"], setColor: ["mkColor", "setColor"], property: ["mkColorProperty", "property"] }, features: [ɵngcc0.ɵɵProvidersFeature([ColorService])] });
BackgroundColorDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ColorService }
];
BackgroundColorDirective.propDecorators = {
    condition: [{ type: Input, args: ['mkColorCondition',] }],
    setPrefix: [{ type: Input, args: ['mkColorPrefix',] }],
    property: [{ type: Input, args: ['mkColorProperty',] }],
    setColor: [{ type: Input, args: ['mkColor',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BackgroundColorDirective, [{
        type: Directive,
        args: [{
                selector: '[mkColor]',
                providers: [ColorService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.ColorService }]; }, { condition: [{
            type: Input,
            args: ['mkColorCondition']
        }], setPrefix: [{
            type: Input,
            args: ['mkColorPrefix']
        }], setColor: [{
            type: Input,
            args: ['mkColor']
        }], property: [{
            type: Input,
            args: ['mkColorProperty']
        }] }); })();
export class ColorDirective {
    constructor(elementRef, renderer2, colorService) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.colorService = colorService;
    }
    set color(color) {
        this.colorService.setFontColor(color);
    }
}
ColorDirective.ɵfac = function ColorDirective_Factory(t) { return new (t || ColorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ColorService)); };
ColorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColorDirective, selectors: [["", "mkFontColor", ""]], inputs: { color: ["mkFontColor", "color"] }, features: [ɵngcc0.ɵɵProvidersFeature([ColorService])] });
ColorDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ColorService }
];
ColorDirective.propDecorators = {
    color: [{ type: Input, args: ['mkFontColor',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColorDirective, [{
        type: Directive,
        args: [{
                selector: '[mkFontColor]',
                providers: [ColorService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.ColorService }]; }, { color: [{
            type: Input,
            args: ['mkFontColor']
        }] }); })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sb3IuZGlyZWN0aXZlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9saWJyYXJ5L2FuZ3VsYXItYWRtaW4tbHRlL3NyYy9saWIvY29sb3IvY29sb3IuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFeEUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7QUFRL0MsTUFBTSxPQUFPLHdCQUF3QjtBQUNwQyxJQWlCQyxZQUNVLFVBQXNCLEVBQ3RCLFNBQW9CLEVBQ3BCLFlBQTBCO0FBQ2xDLFFBSFEsZUFBVSxHQUFWLFVBQVUsQ0FBWTtBQUNsQyxRQUFZLGNBQVMsR0FBVCxTQUFTLENBQVc7QUFDaEMsUUFBWSxpQkFBWSxHQUFaLFlBQVksQ0FBYztBQUNyQyxRQXJCQyxnQ0FBZ0M7QUFDakMsUUFBNEIsY0FBUyxHQUFHLElBQUksQ0FBQztBQUM3QyxJQW1CSSxDQUFDO0FBQ0wsSUFwQkMsSUFBNEIsU0FBUyxDQUFDLE1BQWM7QUFDckQsUUFBRyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztBQUN4QixRQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2hHLElBQUMsQ0FBQztBQUNGLElBQ0MsSUFBc0IsUUFBUSxDQUFDLEtBQWtDO0FBQ2xFLFFBQUcsSUFBSSxLQUFLLEVBQUU7QUFDZCxZQUFLLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3hCLFlBQUssSUFBSSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDbEcsU0FBSTtBQUNKLElBQUMsQ0FBQztBQUVIO3NEQW5CQyxTQUFTLFNBQUMsbUJBQ1QsUUFBUSxFQUFFLFdBQVcsbUJBQ3JCLFNBQVMsRUFBRSxDQUFDLFlBQVksQ0FBQyxlQUMxQjt5V0FDSztBQUFFO0FBQ1csWUFYbUIsVUFBVTtBQUFLLFlBQTFCLFNBQVM7QUFBSyxZQUVoQyxZQUFZO0FBQUk7QUFBSTtBQUNILHdCQVN2QixLQUFLLFNBQUMsa0JBQWtCO0FBQVEsd0JBQ2hDLEtBQUssU0FBQyxlQUFlO0FBQVEsdUJBSTdCLEtBQUssU0FBQyxpQkFBaUI7QUFBUSx1QkFDL0IsS0FBSyxTQUFDLFNBQVM7QUFBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQXNCM0IsTUFBTSxPQUFPLGNBQWM7QUFDMUIsSUFJQyxZQUNVLFVBQXNCLEVBQ3RCLFNBQW9CLEVBQ3BCLFlBQTBCO0FBQ2xDLFFBSFEsZUFBVSxHQUFWLFVBQVUsQ0FBWTtBQUNsQyxRQUFZLGNBQVMsR0FBVCxTQUFTLENBQVc7QUFDaEMsUUFBWSxpQkFBWSxHQUFaLFlBQVksQ0FBYztBQUNyQyxJQUFJLENBQUM7QUFDTCxJQVRDLElBQTBCLEtBQUssQ0FBQyxLQUF5QjtBQUMxRCxRQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3pDLElBQUMsQ0FBQztBQUVIOzRDQVRDLFNBQVMsU0FBQyxtQkFDVCxRQUFRLEVBQUUsZUFBZSxtQkFDekIsU0FBUyxFQUFFLENBQUMsWUFBWSxDQUFDLGVBQzFCO21OQUNLO0FBQUU7QUFDVyxZQXpDbUIsVUFBVTtBQUFLLFlBQTFCLFNBQVM7QUFBSyxZQUVoQyxZQUFZO0FBQUk7QUFBSTtBQUNiLG9CQXNDYixLQUFLLFNBQUMsYUFBYTtBQUFPOzs7Ozs7Ozs7OztBQXpDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQVFBLEFBQUEsQUFBQSxBQUFBLEFBa0JBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBRkEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBcEJBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBb0JBLEFBQUEsQUFuQkEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFDQSxBQUFBLEFBakJBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFUQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFVQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBSUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQXNCQSxBQUFBLEFBQUEsQUFBQSxBQUtBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBRkEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQVJBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFQQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBdkNBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQXVDQSxBQUFBLEFBQUEsQUFBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIFJlbmRlcmVyMiwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDb2xvclNlcnZpY2UgfSBmcm9tICcuL2NvbG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29sb3JzIH0gZnJvbSAnLi9jb2xvci5kZWZpbml0aW9uJztcblxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbWtDb2xvcl0nLFxuICBwcm92aWRlcnM6IFtDb2xvclNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIEJhY2tncm91bmRDb2xvckRpcmVjdGl2ZSB7XG4gIC8vIFRPRE86IEFERCBAUmVxdWlyZWQgZGVjb3JhdG9yXG4gIEBJbnB1dCgnbWtDb2xvckNvbmRpdGlvbicpIGNvbmRpdGlvbiA9IHRydWU7XG4gIEBJbnB1dCgnbWtDb2xvclByZWZpeCcpIHNldCBzZXRQcmVmaXgocHJlZml4OiBzdHJpbmcpIHtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICB0aGlzLmNvbG9yU2VydmljZS5zZXRCYWNrZ3JvdW5kQ29sb3IodGhpcy5jb2xvciwgdGhpcy5jb25kaXRpb24sIHRoaXMucHJvcGVydHksIHRoaXMucHJlZml4KTtcbiAgfVxuICBASW5wdXQoJ21rQ29sb3JQcm9wZXJ0eScpIHByb3BlcnR5ITogc3RyaW5nO1xuICBASW5wdXQoJ21rQ29sb3InKSBzZXQgc2V0Q29sb3IoY29sb3I6IENvbG9ycyB8IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgdGhpcy5jb2xvclNlcnZpY2Uuc2V0QmFja2dyb3VuZENvbG9yKHRoaXMuY29sb3IsIHRoaXMuY29uZGl0aW9uLCB0aGlzLnByb3BlcnR5LCB0aGlzLnByZWZpeCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcmVmaXghOiBzdHJpbmc7XG4gIHByaXZhdGUgY29sb3IhOiBDb2xvcnMgfCBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgcmVuZGVyZXIyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBjb2xvclNlcnZpY2U6IENvbG9yU2VydmljZVxuICApIHt9XG59XG5cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW21rRm9udENvbG9yXScsXG4gIHByb3ZpZGVyczogW0NvbG9yU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgQ29sb3JEaXJlY3RpdmUge1xuICBASW5wdXQoJ21rRm9udENvbG9yJykgc2V0IGNvbG9yKGNvbG9yOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmNvbG9yU2VydmljZS5zZXRGb250Q29sb3IoY29sb3IpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgcmVuZGVyZXIyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBjb2xvclNlcnZpY2U6IENvbG9yU2VydmljZVxuICApIHt9XG59XG4iXX0=